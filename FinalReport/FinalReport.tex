\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[cm]{fullpage}
\usepackage{xcolor}
\usepackage{float}
\usepackage{minted}
\usemintedstyle{manni}

\title{
	Final: Hackcell \\
	\vskip 0.5cm
	\large{A spreadsheet library in Haskell}
}
\author{Joris Burgers - 5545358\\ Lars van den Haak - 3867803\\ Ivo Gabe de Wolff - 4279433}
\begin{document}
	\maketitle
	
	\section{Domain and problem}
	%vA description of your domain and problem and how they translate to code.
	% See the proposal, and update what is still relevant
	% WHy abstraction in the core
	
	\section{Concepts and techniques}
	%The most important concept and techniques used throughout the code.
	% See the status report
	
	\section{Results}
	%results you have achieved, including examples of use of your library or application.
	
	\section{Reflection}
	During the project we have implemented almost all features from the project proposal, except for SQL-like query functions. Those can however be implemented on top of the library. The schedule was realistic.
\\\\	
	Our design has some limitations. When an expression of a field references a non-existing field, there is no way to track this in the dependency graph, as dependants can only be stored for fields that do exist. This would cause that when some field references a non-existing field and then creating that field would not invalidate the first field. The error would still be shown there. This could be fixed relatively easily by either decoupling the dependants from the value of a field, or by creating a separate structure to store the dependants of non-existing fields. Currently we are using a structure that contains the expression and a \texttt{Maybe FieldResult} per field. A \texttt{FieldResult} (with a list of dependants) can thus only be stored when that field has an expression.
\\\\	
	Expressions in our language are untyped. In the wrapper, we throw an error when evaluating expressions that are not well typed. Instead, one could also choose to do implicit coercions. It is not possible to add a static type system, without modifying the core. It was a design decision to not add a static type system.
\\\\
	The code in the core has a lot of \texttt{field value error app} occurrences, to instantiate the type arguments of our data types. This clutters the code. Alternatives would be to use a single type with a type class that has associated types. Those associated types would replace the current type arguments. Furthermore, we require that three type classes hold on the type arguments, namely \texttt{Ord field}, \texttt{HackcelError error field} and \texttt{Apply field value error app}. We could replace those three by a single type class, but that would make the library less flexible. When one would first want to fix the \texttt{field} and \texttt{error} types, the \texttt{HackcelError} type class could already be implemented. Replacing those type classes by a single type class would not allow this.
\\\\
The initial idea was to allow modules to be chained together. This means that a programmer would be provided with a \texttt{Number} module, a \texttt{Boolean} module, a \texttt{String} module and other modules. The programmer could chain these modules to allow for his or her needs and easily combine an existing module with a custom module. In the current implementation of the Wrapper, this is not possible, because it would cause cyclic imports in Haskell. With a change in the Wrapper implementation, it would be possible to allow chaining of modules, but all the types need to be in the same module. This could be a problem if a user wants to add possible values without access to the code of the module.
\\\\
A \texttt{Range} is defined to have a lower bound and an upper bound in the \texttt{Core}. The reason for this implementation is that the \texttt{Core} doesn't know about the internal structure of a field. Given a lower bound and an upper bound, a Wrapper can decide how the range should be handled. In case of \texttt{Sum}, this is easy. There, every dimension of fields can be mapped to a list of fields. If SQL like queries were to be implemented, this is not the case and the internal structure should remain visible. In that case, the programmer of the Wrapper can decide their own structure. If another representation, like an \texttt{Enum} was chosen, this possible representation is lost.
\\\\
The project is eventually designed as was intended in the project proposal. Almost all the requested proposals are implemented in the final solution. The schedule, as designed in the proposal, was not always strictly followed, but in the end, all the features that were envisioned are present.
	%Reflection about what went well or better than expected, and what problems you encountered.
	% - A field that doesn't exist yet, cannot have any dependents.
	% - Core has not a really functional way of programming
	% - Modules and type arguments, discussion Wouter, one type class
	% - Expressions are not typed
	% - Begin was fast, middle not so much and in the end it came nicely together. We got what we envisioned.
	% - WHY U NO DO ENUMS?!?!
	% - Modules could, but slightly different? And modular types etc
	
\end{document}