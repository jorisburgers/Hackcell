\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[cm]{fullpage}
\usepackage{xcolor}
\usepackage{float}
\usepackage{minted}
\usemintedstyle{manni}

\title{
	Final: Hackcell \\
	\vskip 0.5cm
	\large{A spreadsheet library in Haskell}
}
\author{Joris Burgers - 5545358\\ Lars van den Haak - 3867803\\ Ivo Gabe de Wolff - 4279433}
\begin{document}
	\maketitle
	
	\section{Domain and problem}
	%vA description of your domain and problem and how they translate to code.
	% See the proposal, and update what is still relevant
	% WHy abstraction in the core
	
	\section{Concepts and techniques}
	%The most important concept and techniques used throughout the code.
	% See the status report
	
	\section{Results}
	%results you have achieved, including examples of use of your library or application.
	The result that is obtained is a working library for spreadsheets. The core of the library gives a way to store expressions, evaluate them, track dependencies, detect cyclic references and propagate errors. This library can be used by anyone who wants to create a spreadsheet program. The data type where everything is build upon is the Spreadsheet data type:
\begin{minted}{haskell}	
newtype Spreadsheet field value err app =
  Spreadsheet { unSpreadsheet :: Data.Map.Strict.Map field (Expression field value err app) }
\end{minted}
	In the core an expression can be a value, a referenced fields and a function application. An function parameter can be either an expression or a range of fields. What a range of fields is exactly, is not specified in the core for flexibility.

	 A wrapper should be written around the core, which specifies what the types of the fields, the values and the errors are. A few restrictions are on these types, such that we can provide al the needed functionality. Also a data type that conforms to App class should be implemented. In this instance the internal working of functions application should be specified. This leads to these custom classes that should be instanced and on top of that an \texttt{Ord} instance for \texttt{field}.
\begin{minted}{haskell}
class Apply field value err app where
  apply :: app -> [Argument field value err app] -> Eval field value err app value
  
class HackcelError err field | err -> field where
  errorUnknownField :: field -> err
  errorRecursion :: [field] -> err
  errorExpectedValueGotRange :: err
  errorExpectedRangeGotValue :: err
\end{minted}
	
	A few standard utilities are provided, like a pretty printer, throwing custom errors in the monad stack, evaluate all fields and a simple command line interface for debugging. For the pretty printer and command line interface \texttt{Show} instances for \texttt{field}, \texttt{value}, \texttt{err}, \texttt{app} are needed. If functions use range arguments, it should be decided in the wrapper how to handle them. For example make a one dimensional list from a range, a multi dimensional list, etc.
	
	On top of this library, we build a wrapper that supports integers, doubles and bools. The field is not yet specified for this, so it can be used in multiple instances. Function applications supports basic operators like \texttt{+}, \texttt{\&\&}, \texttt{<} and \texttt{If-then-else} constructs.
	
	Two different examples for fields are made, a one dimensional one and a two dimensional one:
\begin{minted}{haskell}
-- One dimensional
data Field = FieldInt Int
-- Two dimensional
data Field = FieldInt (Int, Int)
\end{minted}
	
	
	\section{Reflection}
	%Reflection about what went well or better than expected, and what problems you encountered.
	% - A field that doesn't exist yet, cannot have any dependents.
	% - Core has not a really functional way of programming
	% - Modules and type arguments, discussion Wouter, one type class
	% - Expressions are not typed
	% - Begin was fast, middle not so much and in the end it came nicely together. We got what we envisioned.
	% - WHY U NO DO ENUMS?!?!
	% - Modules could, but slightly different? And modular types etc
	
\end{document}