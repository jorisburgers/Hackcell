\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[cm]{fullpage}
\usepackage{xcolor}
\usepackage{float}
\usepackage{minted}
\usemintedstyle{manni}

\title{
	Final: Hackcell \\
	\vskip 0.5cm
	\large{A spreadsheet library in Haskell}
}
\author{Joris Burgers - 5545358\\ Lars van den Haak - 3867803\\ Ivo Gabe de Wolff - 4279433}
\begin{document}
	\maketitle
	
	\section{Domain and problem}
	%vA description of your domain and problem and how they translate to code.
	% See the proposal, and update what is still relevant
	% WHy abstraction in the core
	
	\section{Concepts and techniques}
	Our project is split in two parts: the core, which implements a generic interface to work with spreadsheets, and a wrapper, which is not generic but practically demonstrates the functionality of the core with an interactive command line interface.
	
	In the core we implement the data types, where we do not specify what the types of the field, the values and the errors should be. The implementation should specify this further.
	
	All the data types that are used in the core can be found in listing \ref{listing:datatypes}. \texttt{Spreadsheet} is used to initialize the \texttt{HackcellState}. The \texttt{HackcellState} saves the expressions and results of all the fields.
	
	\texttt{Eval} is a wrapper with an Except Transformer applied to the State monad. With this we can use a state, that is always passed and the result of the state monad can then either be an error or the normal result. This lets us use all the normal state and error functionality of \texttt{Control.Monad.Except} and \texttt{Control.Monad.State} modules. We put a data type around it, such that users cannot access the state internally. The state that is passed around is the \texttt{EvalState}. This contains the \texttt{HackcellState}, the field that is being calculated (which changes when evaluating a reference to some other field) and the stack of all the fields that are being calculated. The stack is used to detect circular dependencies.
	
	The \texttt{Apply} type class contains the \texttt{apply} function which is used to evaluate function calls. A function call contains a list of parameters that are either an expression or a range. The latter can be used to implement the \texttt{SUM} method from Excel. Since we do not want to pass an expression to the \texttt{app} function, we instead created a new data type, \texttt{Argument}, which is either a value (in the \texttt{Eval} monad) or a range. Given that values are passed in the \texttt{Eval} monad, one can implement lazy operators such an if-then-else construct.

	\texttt{FieldResult} is used to save the results of calculations, either an error or a value. We also store which other fields depend on the result, so that we can recalculate them, if the current field is changed.
	
	\subsection{Dependency tracking}
	We store a list of dependant fields in \texttt{FieldResult}. Every time that we evaluate an expression of field $x$ that depends on some field $y$, we add the $x$ to the dependants list of $y$. This gives a dependency graph which we use when a field changes. When the value of field $y$ is modified, the value of $x$ is invalidated, that is, the memoized value is removed. The dependants are recursively invalidated. Their values are not immediately re-evaluated, but are only evaluated when needed.
	
	\subsection{Monadic interface for function definitions}
	Functions to be used in expression can be defined using the \texttt{Eval} monad.
	
	% TODO
	
	\begin{listing}
		\begin{minted}[
		frame=lines,
		framesep=2mm,
		baselinestretch=0.5,
		fontsize=\footnotesize,
		linenos
		]{haskell}
		newtype Spreadsheet field value err =
		Spreadsheet { unSpreadsheet :: M.Map field (Expression field value err) }
		
		type App field value err = String -> [Argument field value err] -> Eval field value err value
		data HackcelState field value err = HackcelState
		{ fields :: M.Map field (Expression field value err, Maybe (FieldResult field value err))
		, app :: App field value err
		}
		
		newtype Eval field value err a = Eval {
		runEvalState :: ExceptT err (State (EvalState field value err)) a
		} deriving (Monad, Functor, Applicative)
		
		data EvalState field value err = EvalState
		{ esHackcellState :: HackcellState field value err
		, esField :: field
		, esStack :: [field]
		}
		
		data Argument field value err
		= AValue (Eval field value err value)
		| ARange field field
		
		data Parameter field value err  = PExpr (Expression field value err)
		| PRange field field
		
		data FieldResult field value err = FieldResult
		{ fieldValue :: Either err value
		, fieldDependants :: [field] }
		
		class Hackcellerror t field | t -> field where
		errorUnknownField :: field -> t
		errorRecursion :: [field] -> t
		errorExpectedValueGotRange :: t
		errorExpectedRangeGotValue :: t
		
		data Expression field value err
		= ExprField (field)
		| ExprLit value
		| ExprApp String [Parameter field value err]
		\end{minted}
		\caption{The data types used in the core}
		\label{listing:datatypes}
	\end{listing}
	
	\section{Results}
	%results you have achieved, including examples of use of your library or application.
	
	\section{Reflection}
	During the project we have implemented almost all features from the project proposal, except for SQL-like query functions. Those can however be implemented on top of the library. The schedule was realistic.
	
	Our design has some limitations. When an expression of a field references a non-existing field, there is no way to track this in the dependency graph, as dependants can only be stored for fields that do exist. This would cause that when some field references a non-existing field and then creating that field would not invalidate the first field. The error would still be shown there. This could be fixed relatively easily by either decoupling the dependants from the value of a field, or by creating a separate structure to store the dependants of non-existing fields. Currently we are using a structure that contains the expression and a \texttt{Maybe FieldResult} per field. A \texttt{FieldResult} (with a list of dependants) can thus only be stored when that field has an expression.
	
	Expressions in our language are untyped. In the wrapper, we throw an error when evaluating expressions that are not well typed. Instead, one could also choose to do implicit coercions. It is not possible to add a static type system, without modifying the core. It was a design decision to not add a static type system.
	
	The code in the core has a lot of \texttt{field value error app} occurrences, to instantiate the type arguments of our data types. This clutters the code. Alternatives would be to use a single type with a type class that has associated types. Those associated types would replace the current type arguments. Furthermore, we require that three type classes hold on the type arguments, namely \texttt{Ord field}, \texttt{HackcelError error field} and \texttt{Apply field value error app}. We could replace those three by a single type class, but that would make the library less flexible. When one would first want to fix the \texttt{field} and \texttt{error} types, the \texttt{HackcelError} type class could already be implemented. Replacing those type classes by a single type class would not allow this.
	
	
	%Reflection about what went well or better than expected, and what problems you encountered.
	% - A field that doesn't exist yet, cannot have any dependents.
	% - Core has not a really functional way of programming
	% - Modules and type arguments, discussion Wouter, one type class
	% - Expressions are not typed
	% - Begin was fast, middle not so much and in the end it came nicely together. We got what we envisioned.
	% - WHY U NO DO ENUMS?!?!
	% - Modules could, but slightly different? And modular types etc
	
\end{document}