\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[cm]{fullpage}
\usepackage{xcolor}
\usepackage{float}
\usepackage{minted}
\usemintedstyle{manni}

\title{
	Final: Hackcell \\
	\vskip 0.5cm
	\large{A spreadsheet library in Haskell}
}
\author{Joris Burgers - 5545358\\ Lars van den Haak - 3867803\\ Ivo Gabe de Wolff - 4279433}
\begin{document}
	\maketitle
	
	\section{Domain and problem}
	The aim of the project is to provide a library for spreadsheet calculations in Haskell. A spreadsheet is an interactive program where users can perform calculations. It consists of cells, where values or formulas are stored. The cells can be displayed, and will show either the value it contains or the result of the formula it contains. Formulas can reference other cells. Also a range of cells can be provided as argument of a function, for example to calculate the sum or average of a range of cells. 
	
	A common spreadsheet application is Microsoft Excel, where the cells are stored in a two dimensional sheet and a file can contain multiple sheets. Cells can refer to other cells in the same or other sheets.
	
	\subsection{Problem description}
	The problem that Hackcell will solve is the (incremental) calculation of spreadsheets. The library will provide the following functionality:
	\begin{itemize}
		\item The ability to allow arbitrary data types in the same spreadsheet, for values, fields and errors. Users can use their own types and are not limited to a number of predefined types.
		\item Users can specify methods that can be used in the expressions.
		\item Remove the limitation of the number of dimensions. Most spreadsheet programs give the user a limited amount of dimensions to work with. We want to remove this restriction and let a user define a spreadsheet of arbitrary size and dimensions.
		\item Detection of cyclic references. In a spreadsheet, cells can reference other cells and this can cause a cycle. This cycle will be detected, preventing an endless loop.
		\item The possibility to allow users to update specific cells without the need to recompute the entire spreadsheet. The only cells that will be updated are those cells that depend on the changed cell.
		\item The only values that are computed are the values that need to be computed.
	\end{itemize}	
	
	\section{Concepts and techniques}
	%The most important concept and techniques used throughout the code.
	% See the status report
	
	\section{Results}
	%results you have achieved, including examples of use of your library or application.
	
	\section{Reflection}
	During the project we have implemented almost all features from the project proposal, except for SQL-like query functions. Those can however be implemented on top of the library. The schedule was realistic.
	
	Our design has some limitations. When an expression of a field references a non-existing field, there is no way to track this in the dependency graph, as dependants can only be stored for fields that do exist. This would cause that when some field references a non-existing field and then creating that field would not invalidate the first field. The error would still be shown there. This could be fixed relatively easily by either decoupling the dependants from the value of a field, or by creating a separate structure to store the dependants of non-existing fields. Currently we are using a structure that contains the expression and a \texttt{Maybe FieldResult} per field. A \texttt{FieldResult} (with a list of dependants) can thus only be stored when that field has an expression.
	
	Expressions in our language are untyped. In the wrapper, we throw an error when evaluating expressions that are not well typed. Instead, one could also choose to do implicit coercions. It is not possible to add a static type system, without modifying the core. It was a design decision to not add a static type system.
	
	The code in the core has a lot of \texttt{field value error app} occurrences, to instantiate the type arguments of our data types. This clutters the code. Alternatives would be to use a single type with a type class that has associated types. Those associated types would replace the current type arguments. Furthermore, we require that three type classes hold on the type arguments, namely \texttt{Ord field}, \texttt{HackcelError error field} and \texttt{Apply field value error app}. We could replace those three by a single type class, but that would make the library less flexible. When one would first want to fix the \texttt{field} and \texttt{error} types, the \texttt{HackcelError} type class could already be implemented. Replacing those type classes by a single type class would not allow this.
	
	
	%Reflection about what went well or better than expected, and what problems you encountered.
	% - A field that doesn't exist yet, cannot have any dependents.
	% - Core has not a really functional way of programming
	% - Modules and type arguments, discussion Wouter, one type class
	% - Expressions are not typed
	% - Begin was fast, middle not so much and in the end it came nicely together. We got what we envisioned.
	% - WHY U NO DO ENUMS?!?!
	% - Modules could, but slightly different? And modular types etc
	
\end{document}