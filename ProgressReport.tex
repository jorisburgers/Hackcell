\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[cm]{fullpage}
\usepackage{xcolor}
\usepackage{float}
\usepackage{minted}
\usemintedstyle{manni}

\title{
	Progress Report: Hackcell \\
	\vskip 0.5cm
	\large{A spreadsheet library in Haskell}
}
\author{Joris Burgers - 5545358\\ Lars van den Haak - 3867803\\ Ivo Gabe de Wolff - 4279433}
\begin{document}
	\maketitle
	\section{Main Data Types and Techniques}
	In the core we implement the data types, where we do not specify what the data type of the field, the values and the errors should be. The implementation should specify this further, e.g. (Int, Int) for fields, Double for values, and custom data type for errors.
	
	In listing \ref{listing:datatypes} all the data types that are used in the core can be found. \textit{Spreadsheet} is used to initialize the \textit{HackcellState}. The \textit{HackcellState} saves the expressions and results of all the fields. It also contains a function \textit{app}, where all the functions that can be used in the spreadsheet should be defined. \textit{App} takes a String argument that identifies the function.
	
	\textit{Eval} is a wrapper with an ExceptTransformer applied to the State monad. With this we can use a state, that is always passed and the result of the state monad can then either be an error or the normal result. This lets us use all the normal state and error functionality of the \textit{Control.Monad.Except} and \textit{Control.Monad.State} libraries. We put a data type around it, such that users cannot access the state internally. The state that is passes around is the \textit{EvalState}. This contains the \textit{HackcellState}, the field that is being calculated (the first one the user request, because it can recurse) and the stack of all the fields that are being calculated. The stack is used to find circular dependencies.
	
	The arguments and parameters are used for function applications. The argument is eventually passed to the \textit{app} function, it has the Eval monad, and not the expression. The functions in \textit{app} should only work with values or ranges. The error handling of wrong expressions should be handled in the core.
	
	\textit{FieldResult} is used to save the results of calculations, either an error or a value. We also store which other fields depend on the result, so that we can recalculate them, if the current field is changed.
	
	We make a class of standard errors, which the wrapper should implement (with own error messages). And for expressions, we either have a value, a range or an application of a function.
	
	\begin{listing}
	\begin{minted}[
	frame=lines,
	framesep=2mm,
	baselinestretch=0.5,
	fontsize=\footnotesize,
	linenos
	]{haskell}
newtype Spreadsheet field value err =
  Spreadsheet { unSpreadsheet :: M.Map field (Expression field value err) }
     
type App field value err = String -> [Argument field value err] -> Eval field value err value
data HackcelState field value err = HackcelState
  { fields :: M.Map field (Expression field value err, Maybe (FieldResult field value err))
  , app :: App field value err
  }

newtype Eval field value err a = Eval {
  runEvalState :: ExceptT err (State (EvalState field value err)) a
  } deriving (Monad, Functor, Applicative)

data EvalState field value err = EvalState
  { esHackcellState :: HackcellState field value err
  , esField :: field
  , esStack :: [field]
  }

data Argument field value err
  = AValue (Eval field value err value)
  | ARange field field

data Parameter field value err  = PExpr (Expression field value err)
                               | PRange field field
                               
data FieldResult field value err = FieldResult
  { fieldValue :: Either err value
  , fieldDependants :: [field] }

class Hackcellerror t field | t -> field where
  errorUnknownField :: field -> t
  errorRecursion :: [field] -> t
  errorExpectedValueGotRange :: t
  errorExpectedRangeGotValue :: t

data Expression field value err
  = ExprField (field)
  | ExprLit value
  | ExprApp String [Parameter field value err]
	\end{minted}
	\caption{The data types used in the core}
	\label{listing:datatypes}
	\end{listing}
	\section{Progress of Implementation}
	
	\section{Timeline}
		\begin{tabular}{|r|l|l|} \hline
			Week & Deadline &Tasks  \\ \hline \hline
			19 February & Submission of project proposal & Setting up initial framework, start designing the DSL\\ \hline
			26 February &  & Processing feedback on proposal, continuing on framework,\\
			 & & start working on the parser \\ \hline
			5 March & & Finalizing bare minimum framework without \\
			 & & dependency tracking \\ \hline
			12 March & Submission status report & Implementing dependency tracking and \\
			 & & building demo application\\ \hline
			19 March & & Adding advanced functionality to demo\\ \hline
			26 March & & Implementing examples and reserve time for solving issues\\ \hline
			2 April & Presentation \& Submission of project & Finalizing project, preparing presentation\\ \hline
			
		\end{tabular}
	
\end{document}